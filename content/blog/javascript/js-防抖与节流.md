---
title: JS 防抖与节流
date: 2019-03-13 17:03:48
category: javascript
---


## 本文涉及知识点

- 防抖与节流
- 重绘与回流
- 浏览器解析 URL
- DNS 域名解析
- TCP 三次握手与四次挥手
- 浏览器渲染页面


讲到 防抖与节流，我们可以顺带探秘下 重绘与回流。

说起 重绘与回流，我们就顺带把 浏览器输入 URL 后发生的事情 也关注一下，从而引出 DNS、TCP 等知识点，最终串起来构成本文的轮廓。


## 防抖与节流

通过代码去了解某样事物，往往是了解某个知识点最快的形式。

### 防抖

下面我们有段防抖小案例代码

如果小伙伴们手头有电脑，并感兴趣想先自己思考下什么是防抖。可以将代码复制到浏览器，尝试点击按钮，并关注下控制台，看看 `Console` 是如何打印的。


如果小伙伴们手头没有电脑，那么咱一起先瞅瞅代码实现。


```js
// 防抖功能函数，接受传参
function debounce(fn) {
  // 4、创建一个标记用来存放定时器的返回值
  let timeout = null;
  return function() {
    // 5、每次当用户点击/输入的时候，把前一个定时器清除
    clearTimeout(timeout);
    // 6、然后创建一个新的 setTimeout，
    // 这样就能保证点击按钮后的 interval 间隔内
    // 如果用户还点击了的话，就不会执行 fn 函数
    timeout = setTimeout(() => {
      fn.call(this, arguments);
    }, 1000);
  };
}
```

防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。

结合上面的代码，我们可以了解到，在触发点击事件后，如果用户再次点击了，我们会清空之前的定时器，重新生成一个定时器。意思就是：这件事儿需要等待，如果你反复催促，我就重新计时！

空讲无益，`show you` 场景：

有个输入框，输入之后会调用接口，获取联想词。但是，因为频繁调用接口不太好，所以我们在代码中使用防抖功能，只有在用户输入完毕的一段时间后，才会调用接口，出现联想词。

小伙伴们可以尝试看着上面的案例，先自己实现一遍这个场景的解决，如果感觉不行，那就看：

[《防抖和节流的应用场景和实现》](https://www.codercto.com/a/35263.html)


知识点补充：何为 `arguments`？
首先，后端转前端的同学，可以将 `arguments` 理解为能实现重载函数功能的工具。
然后，我们举个例子：在 `function test()` 这个方法中，由于我们不确定变量有多少，比如 `test("jsliang", 24)`，又或者 `test("LiangJunrong", "jsliang", "24")`，这时候只需要在函数 `test` 中用 `arguments` 接收就行了。
最后，在 `function test() { let arr1 = argument[0] }` 中，`arr1` 就可以获取到传进来的第一个变量。
所以，`fn.call(this, arguments)` 其实是将不确定变量替换到函数中了。








